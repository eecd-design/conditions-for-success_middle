---
import { getCollection } from "astro:content";

import Accordion from "../components/Accordion.astro";
import ResourceLink from "./ResourceLink.astro";

import PhaseIcons from "./icons/PhaseIcons.astro";
import IconFlag from "./icons/IconFlag_24.astro";
import IconFocus from "./icons/IconTarget_20.astro";
import IconCompass from "./icons/IconCompass_14.astro";
import IconCheckmark from "./icons/IconCheckmark_12.astro";
import IconCaretDown14 from "./icons/IconCaretDown_14.astro";

const { entry } = Astro.props;

// Store the path to the current component
const pathToComponent = `src/content/components/${entry.id}`;

// Get all component descriptions
let allDescriptions = Object.values(
	import.meta.glob("src/content/components/**/description.md", {
		eager: true,
	}),
);

// Get the current reflection question
let description:any = allDescriptions.find((match:any) =>
	match.file.includes(pathToComponent),
);

// Get all reflection questions
let allQuestions = Object.values(
	import.meta.glob("src/content/components/**/reflectionQuestion.md", {
		eager: true,
	}),
);

// Get the current reflection question
let question:any = allQuestions.find((match:any) =>
	match.file.includes(pathToComponent),
);

// Get all component goals
let allGoals = Object.values(
	import.meta.glob("src/content/components/**/goal.md", {
		eager: true,
	}),
);

// Get the current component goal
let goal:any = allGoals.find((match:any) =>
	match.file.includes(pathToComponent),
);

// Get all component focus statements
let allFocuses = Object.values(
	import.meta.glob("src/content/components/**/focus.md", {
		eager: true,
	}),
);

// Get the current component focus statements
let focuses = Object.fromEntries(allFocuses
.filter((match:any) => match.file.includes(pathToComponent))
.map((match:any) => {
    let path = match.file.split('/');
    let id = path[path.length - 2];
    return [id, match]
}));

// Get all resources
let allResources = await getCollection("resources");

let filterResourcesByPhase = (resources, phase) => {
	
	return resources.filter((resource) => {

		let targetIndicator = entry.data?.tag.split('.')[0];
		let targetComponent = entry.data?.tag;
		let targetConsiderations = new Set(entry.data[phase]?.considerations.map((c) => c.tag));

		let matchesIndicator = resource.data.linkedIndicators.includes(targetIndicator);
		let matchesComponent = resource.data.linkedComponents.includes(targetComponent);
		let matchesConsideration = false;
		for (let consideration of resource.data.linkedConsiderations) {
			if (targetConsiderations.has(consideration)) matchesConsideration = true;
		}

		if (matchesIndicator || matchesComponent || matchesConsideration) {
			return resource
		}

	})
}

let phases = [
	{
		key: 'initiating',
		title: 'Initiating',
		resources: filterResourcesByPhase(allResources, 'initiating'),
	},
	{
		key: 'implementing',
		title: 'Implementing',
		resources: filterResourcesByPhase(allResources, 'implementing'),
	},
	{
		key: 'developing',
		title: 'Developing',
		resources: filterResourcesByPhase(allResources, 'developing'),
	},
	{
		key: 'sustaining',
		title: 'Sustaining',
		resources: filterResourcesByPhase(allResources, 'sustaining'),
	},
]

---

<section class="component" data-component-tag={entry.data.tag}>

	<p class="phase-status" data-field="currentPhase" data-restrict-mode="assessment">Initiating</p>

	<h2 id={`component-${entry.data.tag.replaceAll('.', '-')}`}>
		<span class="tag" data-font-type="sans-serif">
			<span class="number">{entry.data?.tag}</span>
		</span>
		<span class="title">{entry.data?.title}</span>
	</h2>
	
	{ description && description.rawContent().trim().length > 0 && (
	
		<description.Content />
	
	)}
	
	{ question && question.rawContent().trim().length > 0 && (
	
		<div class="reflection-question callout" data-style="outline" data-elem-on-path="heading">
			<h3 class="heading">Reflection Question</h3>
			<question.Content />
		</div>
	
	)}
	
	{ goal && goal.rawContent().trim().length > 0 && (
		<h3>
			<IconFlag/>
			<span class="text">Goal</span>
		</h3>
		<goal.Content />
	)}
	
	<div class="accordion-group">
	
		{ phases.map((phase) => {
	
			if (!entry.data) return;
	
			let focus = focuses[phase.key];
			let considerations = entry.data[phase.key]?.considerations ?? null;
			let considerationsCount = considerations ? considerations.length : null;
			// let resources = phase.resources;

			for (let consideration of considerations) {
				let targetConsideration = consideration.tag;
				consideration.resources = allResources.filter((resource) => {
					for (let linkedConsideration of resource.data.linkedConsiderations) {
						if (targetConsideration === linkedConsideration) {
							return true; // stop early, match found
						}
					}
					return false;
				})
			}
	
			return (
	
				<Accordion title={phase.title} id={`component-${entry.data.tag.replaceAll('.', '-')}_${phase.title.toLowerCase()}`} dataset={[{key: 'phase', value: phase.key}]} crossIconSize={'medium'} wrapper={false}>
	
					<PhaseIcons phase={phase.key} slot="button-icon"/>
	
					{ considerationsCount && (
						<span class="considerations-status label-container field-container"  data-restrict-mode="assessment" slot="button-meta">
							<span class="label" data-field="considerationsEstablished">0</span>&nbsp;/ {considerationsCount} Established
						</span>
					)}
	
					<div>
	
						{
							focus && focus.rawContent().trim().length > 0 && (
								<div class="focus-container">
									<h4 class="label">
										<IconFocus />
										<span>Focus</span>
									</h4>
									<div class="statement">
										<focus.Content />
									</div>
								</div>
							)
						}
	
						{
							considerations && considerationsCount > 0 && (
	
								<div class="considerations-container">
									<ul class="considerations-list">
										{
											considerations.map((consideration) => {
	
												return (
													<li>
														<div class="label-group">
															<form>
																<label>
																	<input name="considerationsEstablished" type="checkbox" value={consideration.tag}/>
																	<IconCheckmark/>
																	<span class="tag">{consideration.tag}</span>
																	{consideration.compass && (
																		<IconCompass />
																	)}
																</label>
															</form>
															{ consideration.categories && consideration.categories.length > 0 && (
																<ul class="categories-list">
																	{ consideration.categories.map((category) => (
																		<li>
																			<div class="label-container" data-style="outline">
																				<div class="label">{category}</div>
																			</div>
																		</li>
																
																	)) }
																</ul>
															)}
														</div>
	
														<div class="description-container">
															<p>{consideration.description}</p>
														</div>

														{ consideration.resources && consideration.resources.length > 0 && (

															<details class="resources">
																<summary>
																	<span>Resources relevant to {consideration.tag}</span>
																	<IconCaretDown14/>
																</summary>

																<div class="contents">
																	<ul class="link-list" data-style="divided">
																		{
																			consideration.resources.map((resource) => {
																				let { data } = resource;
																				let { title, linkedIndicators, linkedComponents, linkedConsiderations } = data;
																				return (
																					<li data-title={title.toLowerCase()}
																						data-indicators={JSON.stringify(linkedIndicators)} data-components={JSON.stringify(linkedComponents)} data-considerations={JSON.stringify(linkedConsiderations)}>
																						<ResourceLink resource={resource}/>
																					</li>
																				)
																			}
																		)}
																	</ul>
																</div>

															</details>
	
														)}
	
													</li>
												)
											})
										}
									</ul>
								</div>
	
							)
						}
	
					</div>
	
				</Accordion>
	
			)
	
		}) }
	
	</div>

</section>

<style is:global>

	/*
	** PHASE STATUS
	------------------------------*/

	.phase-status {
		line-height: 1.2;
		margin: 0 0 1rem;
		color: var(--colour-ui-accent-subtle)
	}

	[data-mode="assessment"] .phase-status ~ h2 {
		margin-top: 0;
	}


	/*
	** REFLECTION QUESTION
	------------------------------*/

	.reflection-question.callout {
		width: 100%;
	}

	.reflection-question.callout p {
		font-size: 1.25rem;
		font-weight: 600;
		line-height: 1.5;
		width: 100%;
	}
	
	/*
	** FOCUS
	------------------------------*/
	
	.focus-container {
		display: flex;
		flex-flow: row nowrap;
		gap: 1rem;
		align-items: center;
		padding: 0.75rem 1.25rem;
		background-color: var(--colour-fill-neutral-subtle);
		border-bottom: 1px solid var(--colour-border-neutral-subtle);
	}

	.focus-container .label {
		--icon-colour: var(--colour-ui-neutral-subtle);
		--icon-size: 1.25rem;
		display: flex;
		flex-flow: row nowrap;
		gap: 0.5rem;
		align-items: center;
		margin: 0;
		padding: 0;
		font-size: 1rem;
		line-height: 1;
		height: 100%;
	}

	.focus-container .statement  {
		border-left: 1px solid var(--colour-border-neutral-subtle);
		padding: 0 0 0 1rem;
	}


	/*
	** CONSIDERATIONS
	------------------------------*/

	.considerations-list {
		padding: 0;
		list-style-type: none;
	}

	.considerations-list > li {
		padding: 1.25rem;
	}

	.considerations-list > li:not(:first-of-type) {
		border-top: 1px solid var(--colour-border-neutral-subtle);
	}

	.considerations-list .label-group {
		margin: 0 0 0.75rem;
	}

	.considerations-list .label-group .categories-list {
		list-style-type: none;
		margin: 0;
		padding: 0;
	}

	.considerations-list .label-group .categories-list .label-container {
		height: 1.5rem;
	}

	.considerations details.resources {
		margin: 0.75rem 0 0;
	}

	.considerations-list form label {
		display: flex;
		align-items: center;
		height: 1.5rem;
		padding: 0 0.5rem 0 0;
		background-color: var(--colour-fill-accent-subtle);
		border-radius: var(--border-radius-small);
		cursor: pointer;
		user-select: none;
		position: relative;
		transition: background-color var(--transition-linear-fast);	
	}

	.considerations-list form label:has(input[type="checkbox"]:is(:hover, :focus-visible)) {
		background-color: var(--colour-fill-accent-subtle-highlight);
	}

	.considerations-list form label:has(input[type="checkbox"]:checked) {
		background-color: var(--colour-fill-accent-bold);
	}

	.considerations-list form label input {
		height: 1.5rem;
		width: 1.5rem;
		opacity: 0;
		cursor: pointer;
		z-index: 0;
	}

	.considerations-list form label::before {
		content: "";
		position: absolute;
		height: 1.5rem;
		width: 1.5rem;
		background-color: var(--colour-background);
		border: 2px solid var(--colour-border-accent-mid);
		border-radius: var(--border-radius-small);
		pointer-events: none;
		z-index: 1;
		transition: border-color var(--transition-linear-fast);
	}

	.considerations-list form label:has(input[type="checkbox"]:is(:hover, :focus-visible, :checked))::before {
		border-color: var(--colour-border-accent-bold);
	}

	.considerations-list form label .tag {
		margin: 0 0 0 0.375rem;
		font-size: 0.875rem;
		font-weight: 700;
		line-height: 1;
		color: var(--colour-ui-accent);
		transition: color var(--transition-linear-fast);
	}

	.considerations-list form label:has(input[type="checkbox"]:is(:hover, :focus-visible)) .tag {
		color: var(--colour-ui-accent-bold);
	}

	.considerations-list form label:has(input[type="checkbox"]:checked) .tag {
		color: var(--colour-ui-reverse);
	}
	
	.considerations-list form label .icon.checkmark {
		--icon-colour: var(--colour-ui-accent);
		--icon-size: 0.75rem;
		position: absolute;
		top: 0.375rem;
		left: 0.375rem;
		z-index: 2;
		opacity: 0;
		transition: opacity var(--transition-linear-fast);
	}
	
	.considerations-list form label:has(input[type="checkbox"]:is(:hover, :focus-visible, :checked)) .icon.checkmark {
		opacity: 1;
	}
	
	.considerations-list form label .icon.compass {
		--icon-colour: var(--colour-ui-accent);
		--icon-size: 0.875rem;
		margin: 0 0 0 0.25rem;
	}

	.considerations-list form label:has(input[type="checkbox"]:checked) .icon.compass {
		--icon-colour: var(--colour-ui-reverse);
	}

	main:not([data-mode="assessment"]) .considerations-list form label {
		pointer-events: none;
	}

	main:not([data-mode="assessment"]) .considerations-list form label :is(input, .icon.checkmark),
	main:not([data-mode="assessment"]) .considerations-list form label::before {
		display: none;
	}


	/*
	** RESOURCES
	------------------------------*/

	.considerations-list .resources {
		margin: 0.75rem 0 0;
	}


</style>

<script>

	//
	// Imports
	//

	import { filter } from "src/utilities/filter";

	import {
		updateChangeLog,
		getActiveAssessmentData,
		subscribe,
		setAssessment,
		updateContinuumCompletion
	} from "src/stores/userDataStore.js";

	//
	// Variables
	//


	//
	// Methods
	//

	let updateConsiderations = () => {

		let assessment = getActiveAssessmentData();
		if (!assessment) return;
		
		let currentIndicatorTag = document.querySelector('main').getAttribute('data-indicator-tag');
		if (!currentIndicatorTag) return;

		let relevantConsiderationsEstablished = assessment.considerationsEstablished.filter((consideration) => {

			if (!consideration) return;

			// Match pattern like 1.2.3
			let match = consideration.match(/^(\d+)\.\d+\.\d+$/);
			if (!match) return false;
			
			// Check if the first digit matches the current indicator
			return match[1] === currentIndicatorTag;

		});


		// 1. Update checkboxes to match checked state
		for (let consideration of relevantConsiderationsEstablished) {

			let input = document.querySelector(`input[value="${consideration}"]`) as HTMLInputElement;

			input.checked = true;

		}

		// 2. Update consideration status on accordion buttons
		
		let completion = {}

		let componentSections = document.querySelectorAll('section[data-component-tag]');
		
		for (let component of componentSections) {

			let tag = component.getAttribute('data-component-tag');

			let accordions = component.querySelectorAll('.accordion');

			completion[tag] = {};
	
			for (let accordion of accordions) {

				let heading = accordion.querySelector('.heading');
				let panel = accordion.querySelector('.panel');

				let phase = accordion.getAttribute('data-phase');
		
				let inputs = panel.querySelectorAll('input[name="considerationsEstablished"]');
				let checkedInputs = panel.querySelectorAll('input[name="considerationsEstablished"]:checked');
	
				let considerationStatusField = heading.querySelector('[data-field="considerationsEstablished"]');
	
				if (!considerationStatusField) continue;
	
				considerationStatusField.textContent = String(checkedInputs.length);
	
				completion[tag][phase] = checkedInputs.length / inputs.length;
	
			}

		}

		// 3. Update the current phase per component
		let phaseStatusFields = document.querySelectorAll('[data-field="currentPhase"]');

		for (let field of phaseStatusFields) {

			let tag = field.closest('[data-component-tag]')?.getAttribute('data-component-tag');

			if (!tag) return;

			let phase = assessment.continuumCompletion[tag]?.phase ?? 'Initiating';

			field.textContent = phase;

		}

	}

	//
	// Inits & Event Listeners
	//

	subscribe(updateConsiderations);

	document.addEventListener("input", async (event) => {

		let target = event.target as HTMLInputElement;

		if (target.matches(`input[name="considerationsEstablished"]`)) {

			let assessment = getActiveAssessmentData();

			let operation = null;
			let changeMessage = null;

			if (target.checked) {

				if (assessment.considerationsEstablished.includes(target.value)) return;

				assessment.considerationsEstablished.push(target.value);

				operation = 'add';

				changeMessage = `Marked ${target.value} as established`;

			} else {

				let index = assessment.considerationsEstablished.indexOf(target.value);

				if (index === -1) return;

				assessment.considerationsEstablished.splice(index, 1);

				operation = 'substract';

				changeMessage = `Updated ${target.value} as not established`;

			}

			let updatedChangeLog = updateChangeLog({
				message: changeMessage,
			})

			let updatedContinuumCompletion = await updateContinuumCompletion({
				considerationTag: target.value,
				operation: operation,
			})

			setAssessment({
				changeLog: updatedChangeLog,
				considerationsEstablished: assessment.considerationsEstablished,
				continuumCompletion: updatedContinuumCompletion,
			})

		}

	});

	filter.init();
	document.addEventListener('astro:before-swap', filter.destroy);
	document.addEventListener('astro:after-swap', filter.init);

</script>